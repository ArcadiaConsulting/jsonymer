<div id="docs" ng-controller="DocsController">

  <h2>Documentation and Examples</h2>
  
  <div class="cf">

    <div id="doc-items">

      <ul>
        <li class="head">{{overall.label}}</li>
        <li 
          ng-repeat="section in overall.sections" 
          ng-class="{active : isActive(section)}"
          ng-click="makeActive(section.idx, true)">
          {{section.name}}
        </li>          
      </ul>

      <ul>
        <li class="head">{{methods.label}}</li>
        <li 
          ng-repeat="section in methods.sections" 
          ng-class="{active : isActive(section)}"
          ng-click="makeActive(section.idx, true)">
          {{section.name}}
        </li>          
      </ul>

      <ul>
        <li class="head">{{events.label}}</li>
        <li 
          ng-repeat="section in events.sections" 
          ng-class="{active : isActive(section)}"
          ng-click="makeActive(section.idx, true)">
          {{section.name}}
        </li>          
      </ul>

<!--       <ul>
        <li 
          ng-repeat="section in sections" 
          ng-class="{head : section.head, active : isActive(section)}"
          ng-click="makeActive($index, true)">
          {{section.label}}
        </li>          
      </ul> -->
    


    </div>

    <div id="doc-content">
      

      <div class="block">
        <a target="Basic Use"></a>
        <h2>Basic Use</h2>
        <div class="p">
          <markdown-element>
            Include the web component file in your webpage *head* (or at the top of another component)

            ```markup
            &lt;link rel="import" href="jsonymer-editor.html"&gt;
            ```

            Then, place your `jsonymer-editor` element where you'd like it to be

            ```markup
            &lt;jsonymer-editor id="myJsonEditor">&lt;/jsonymer-editor>
            ```

            Finally, but optionally, give your editor some initial object for editing. If you don't do this, you'll simply start with an empty object. There are two ways to init an object with jsonymer:
            <br/><br/>
            *On the element tag itself using the obj attribute (kinda ugly though)*

            ```markup
&lt;!-- (repeat: kinda ugly though) -->
&lt;jsonymer-editor obj="{firstname:'Joe'}">&lt;/jsonymer-editor>
            ```

            *Or, through the Javascript element (by changing the obj property)*
            ```javascript
var jsonymerEditor = document.getElementById('myJsonymer');

jsonymerEditor.obj = {
  firstname : 'Joe',
  type : 'Banana'
};
            ```
            Keep in mind, any time you change the *obj* property the editor will update automatically!
          </markdown-element>
        </div>
      </div>
      



      <div class="block">
        <a target="The jsonymer data structure"></a>
        <h2>The jsonymer data structure</h2>
        <div class="p">
          <markdown-element>
            Although your JSON data may be very simple, the underlying jsonymer data structure needs to be slightly more complex. This is not only to deal with all of the user's edits, but also to be the most performant when working with deep objects.

            When dealing with the API methods and events, many times you'll receive what is called an `item object`. This is the internal data format for the specific JSON `key : value` pair that you are working with. Below is a description of this object.
          </markdown-element>
        </div>
        <div class="detail">
          <h4>item object</h4>
          <div class="cf">
            <span>id</span>
            <p>the unique index ID of the item</p>
          </div>
          <div class="cf">
            <span>key</span>
            <p>the key of the key -> value pair</p>
          </div>
          <div class="cf">
            <span>value</span>
            <p>the value of the key -> value pair</p>
          </div>
          <div class="cf">
            <span>parent</span>
            <p>a reference to the parent item object</p>
          </div>
          <div class="cf">
            <span>type</span>
            <p>the type of the item (text / object / array)</p>
          </div>
          <div class="cf">
            <span>childKeyIdx</span>
            <p>A unique key index that increments along with each child object (if necessary). This helps the automatic key generator be more efficient.</p>
          </div>
        </div>
        <div class="p">
          <markdown-element>
            Note that the item object for the top level (which holds all top level items) has an id of `-1`.
          </markdown-element>
        </div>
      </div>


      <div class="block">
        <a target="Dealing with falsey values and types"></a>
        <h2>Dealing with falsey values and types</h2>
        <p>
          <markdown-element>
            When parsing JSON, any key -> value pair with a value of `undefined` gets left behind. It's a little bit different with the jsonymer editor. All falsey values (except _undefined_) get parsed into their string representations in the editor so they can show up inside the span element accurately. Properties with a value of `undefined` will get inserted into the editor as items _with no determined type_.
            <br/><br/>
            However, when you receive the object back through `.toJSON()`, you have some options. Passing true as the first argument will try and convert types away from a simple string if possible. Types that may be converted are `ints/floats`, `null`, `undefined`, `true`, and `false`. So, if a user types "null" into a value box, the result of `.toJSON(true)` will convert that value to actual `null`. By not passing *true*, that "null" value will stay as the string representation. This will also work if a user types _undefined_ into a string item value.
            <br/><br/>
            This is more important with _undefined_, because, as noted before, calling `JSON.stringify` will ignore any `key : value` pair that hold undefined as a value.
            <br/><br/>
            Empty strings will stay empty strings.
          </markdown-element>
        </p>
      </div>

      <div class="block">
        <a target="Dealing with errors"></a>
        <h2>Dealing with errors</h2>
        <p>
          <markdown-element>
            The only error that jsonymer handles for you internally is the *duplicate key* error. This occurs when two (or more) keys in the same level are identical. When this happens, all offending keys are colored red and given an error icon. If you do not want this error to be handled, set the `errorsOn` property on the jsonymer instance to _false_.
            <br/><br/>
            You can also set your own errors using the `.setError()` and `.clearError()` methods.
            <br/><br/>
            *Note:* if `errorsOn = false`, no errors, internal or custom, will be set.
          </markdown-element>
        </p>
      </div>








      <div id="methods-list" class="block">

        <h2>Methods & Properties</h2>
        <p id="about-methods">
          Although there are many other methods on the Polymer Element, the below methods are the most reliable for you to use externally, and also are probably the only ones you would want/need to use.
        </p>
        
        <doc-item ng-repeat="item in methods.sections" methoddata="{{item}}"></doc-item>

      </div>
      <!-- end method list -->


      <div id="events-list" class="block">

        <h2>Events</h2>
        
        <p id="about-events">
          <markdown-element>
            The following events can be listened to on your jsonymer-element using both inline syntax and `.addEventListener` syntax. All event callbacks are given an `event` object as the first argument. The `event.detail` property provides specific details relative to the JSON structure, as defined in each event's description below.
            <br/><br/>
            *Note:* The following inline-syntax example only works when nested inside a polymer element. Otherwise, use the `.addEventListener` method.
            ```markup
  &lt;jsonymer-editor on-edit="myEditMethod" on-itemAdded="{{anItemWasAdded}}">&lt;/jsonymer-editor>
            ```
            *or*
            ```markup
  &lt;jsonymer-editor id="editor">&lt;/jsonymer-editor>
  &lt;script>
    document.getElementById('editor').addEventListener('itemAdded', function(e){
      console.log("An item was added!");
    }, false);
  &lt;/script>
            ```
          </markdown-element>
        </p>

        <event-item ng-repeat="item in events.sections" eventdata="{{item}}"></event-item>


      </div>



    </div>

  </div>

</div>