<link rel="import" href="bower_components/polymer/polymer.html">


<polymer-element name="jsonymer-editor" attributes="obj">

  <template>
    <style>

      .cf:before,
      .cf:after {
          content: " "; /* 1 */
          display: table; /* 2 */
      }
      .cf:after {
          clear: both;
      }
      .noselect {
          -webkit-touch-callout: none;
          -webkit-user-select: none;
          -khtml-user-select: none;
          -moz-user-select: none;
          -ms-user-select: none;
          user-select: none;
      }

      div#wrap{
        background:#FFF;
        margin: 10px;
        font-size: 14px;
        font-family: helvetica;
        padding: 10px 4px;
        border: 1px solid gainsboro;
        cursor: default;
      }
      ul#master{
        padding: 0px 20px 20px 40px;
        border-left: 1px dashed #CCC;
        margin:4px 6px;
      }

      #none-found{
        padding: 20px;
        font-size: 18px;
        color: #999;
      }
      ul, li{
        list-style: none;
        position: relative;
        margin: 0;
        padding:0;
      }

      ul.group{
        float: none;
        clear: both;
      }
      ul.group li ul{
        padding: 0 0 0 40px;
        border-left: 1px dashed #CCC;
      }
      li.item{
        margin: 10px 0px 10px 0px;
        position: relative;
      }
      li.item[locked]{
        background: #EEE;
      }
      li.item[locked] span{
        color: #999;
      }
      li.item[error]:before{
        content: '';
        background: rgb(255, 202, 202);
        position: absolute;
        right: 0;
        top: -2px;
        bottom: 0;
        width: 100%;
        height: 20px;
        padding: 4px;
        z-index: -1;
      }
      li.item span{
        display: inline-block;
        outline: none;
        vertical-align: top;
      }
      li.item span.key{
        color: rgb(51, 160, 51);
        float: left;
        position: relative;
      }
      li span.value{
        font-weight: 400;
        color: #777;
        max-width: 500px;
      }
      li span.value,
      li span.key-value{
        cursor: text;
      }
      .horiz-border, ul.group li ul li span.horiz-border{
        position: absolute;
        width: 30px;
        height: 1px;
        border-bottom: 1px dashed #CCC;
        left: -35px;
        top: 7px;
      }
      li.item span.dash{
        width: 16px;
        height: 10px;
        margin: 3px 5px 0px 7px;
        position: relative;
        background-image: url(images/arrow-right.png);
        background-size: 100%;
        background-repeat: no-repeat;
      }
      li.item span.dash.object-dash{
        margin: 3px 5px;
      }
      li.item[error] > span.horiz-border{
        border-color: rgb(223, 90, 90);
      }
      li.item[error] > span.key{
        color: FIREBRICK;
      }
      li.item[error] > span.key span.dash,
      li.item[error] > span.dash:before{
        background: rgb(223, 90, 90);
        opacity: 1;
      }
      li.item[error] > span.key span.dash:before,
      li.item[error] > span.dash:before{
        content: '';
        position: absolute;
        top: -2px;
        background-image: url(images/error.png);
        background-size: 100%;
        background-position: center;
        background-repeat: no-repeat;
        width: 100%;
        height: 16px;
        background-color: #FFF;
      }

      a{
        color: #555;
        cursor: default;
      }
      a:hover{
        text-decoration: underline;
      }

      a.add-item{
        position: relative;
        background-image: url(images/plus.png);
        background-position: 0px;
        background-size: 200%;
        background-repeat: no-repeat;
        width: 12px;
        height: 12px;
        cursor: default;      
      }
      a.add-item-child{
        position: absolute;
        right: -10px;
        top: 3px;
      }
      a.add-item-master{
        float: left;
        margin-top: 3px;
        /*margin-left: 5px;      */
      }
      a.add-item:focus,
      a.add-item:hover{
        background-position: -12px 0px;
        outline: none;
      }
      a.add-item:after{
        content: '';
        position: absolute;
        top: 0px;
        left: 0px;
        bottom: 0px;
        width: 100px;
      }
      a.add-item:focus:after,
      a.add-item:hover:after{
        content: 'add new item';
        position: absolute;
        font-size: 12px;
        color: #72cbeb;
        left: 6px;
        width: 100px;
        top: -1px;
        padding-left: 10px;
      }
      span.key-value::selection, 
      span.value::selection{
        background: #CDEEC7;
      }
      span.key-value[contenteditable],
      span.value[contenteditable]{
        box-shadow:0px 2px #72CBEF;
        outline: none;
      }
      span.key-value[contenteditable]:empty,
      span.value[contenteditable]:empty{
        width: 20px;
      }
      span.key-value[contenteditable][error]{
        box-shadow:0px 2px rgb(223, 90, 90);
      }
      span.key-value[disabled]{
        color: #999;
        cursor: default;
      }
/*      span.key-value,
      span.value {
        -webkit-user-select: none;
        -moz-user-select: none;
        -khtml-user-select: none;
        -ms-user-select: none;
      }*/
      .bracket{
        color: #868686;
        padding-right: 10px;
      }
      .master-bracket{
        float: left;
        padding-right: 5px;
      }
      .bracket.obj:after{
        padding-left: 4px;
        content: '{';
      }
      .bracket.arr:after{
        padding-left: 4px;
        content: '[';
      }
      .bracket.bracket-close.obj:after{
        padding-left: 0;
        content: '}';
      }
      .bracket.bracket-close.master-bracket.obj:after{
        padding-left: 6px;
      }
      .bracket.bracket-close.arr:after{
        padding-left: 0;
        content: ']';
      }
      a.new-item-option{
        font-size: 14px;
        cursor: default;
        margin-right: 5px;
        text-align: center;

        background-size: 100%;
        background-repeat: no-repeat;
        width: 18px;
        height: 18px;
        display: inline-block;
        opacity: .5;
      }
      a.new-item-option:hover{
        text-decoration: underline;
        opacity: 1;
      }
      a.new-item-option:focus{
        outline: none;
        color: #72cbeb;
        opacity: 1;
      }
      a.new-item-option.new-item-text{
        background-image: url(images/text.png);
      }
      a.new-item-option.new-item-object{
        background-image: url(images/obj-bracket.png);
      }
      a.new-item-option.new-item-array{
        background-image: url(images/array-bracket.png);
      }
      div.controls{
        position: absolute;
        left: -40px;
        width: 40px;
        opacity: 0;
      }
      div.delete{
        float: left;
        font-size: 14px;
        padding: 0px 3px;
        cursor: default;
        color: firebrick;
        margin-top: 1px;
        font-weight: 700;

        background-image: url(images/x.png);
        background-position: center;
        background-repeat: no-repeat;
        background-size: 100%;
        width: 11px;
        height: 11px;
        margin-left: 2px;
        padding: 0;
        margin-top: 3px;
      }
      div.remove-type{
        float: left;
        width: 6px;
        font-size: 14px;
        padding: 0px 3px;
        margin-top: 0px;
        color: TOMATO;
        cursor: default;
        margin-left: 6px;
        font-weight: 700;

        background-image: url(images/back.png);
        background-position: center;
        background-repeat: no-repeat;
        background-size: 100%;
        width: 16px;
        height: 16px;
        margin-left: 6px;
        padding: 0;
        margin-top: 0px;
      }
      div.delete:hover,
      div.remove-type:hover{
        opacity: .7;
      }
      li.item > span.key:hover > div.controls{
        opacity: 1;
      }
      ul.group li ul.empty{
        padding: 0px 0px 0px 20px;
        font-size: 12px;
        color: #AAA;
        font-style: italic;
      }
    </style>

    <div id="wrap">

      <div class="cf">
        <span class="bracket obj master-bracket"></span>
        <a id="add-item-start" class="add-item add-item-master noselect" on-click="{{addItem}}" tabindex="1" on-keyDown="{{onEnterDoClick}}"></a>
      </div>

      <template if="{{cObj}}">

          <ul id="master" class="group cf">

            <!-- main loop template -->
            <template id="loop_root" repeat="{{item in cObj.value}}">

              <!-- each individual item will be one of these: li.item -->
              <li id="item-{{item.idx}}" class="item cf" locked?="{{item.locked}}" on-mouseenter="{{showControls}}" on-mouseleave="{{hideControls}}">


                <!-- horizontal border for visual reference with nested children -->
                <span class="horiz-border"></span>


                <!-- the items key -->
                <span class="key">

                  <div class="controls cf">
                    <div class="delete" data-idx="{{item.idx}}" on-click="{{removeItem}}" title="Remove Item"></div>
                    <template if="{{item.type}}">
                      <div data-idx="{{item.idx}}" class="remove-type" on-click="{{removeType}}" title="Reset Item Type"></div>
                    </template>
                  </div>
                  

                  <span 
                  data-idx="{{item.idx}}" 
                  class="key-value" 
                  contenteditable?="{{item.editmode}}"
                  on-focus="{{doFocus}}" 
                  on-keyDown="{{checkEnterKey}}"
                  on-keyUp="{{doKeyUp}}"
                  on-input="{{doInput}}"
                  on-blur="{{doBlur}}"
                  tabIndex="{{item.parent && item.parent.type == 'array' ? -1 : 1}}"
                  disabled?="{{item.parent && item.parent.type == 'array'}}"
                  >{{item.key}}</span>
                  
                  <!-- if the item has a value and its value is object/array, show the opening bracket -->
                  <template if="{{item.value | isObject}}">
                    <span class="dash object-dash"></span>
                    <span class="bracket {{item.type=='object'?'obj':'arr'}}"></span>
                    <a data-idx="{{item.idx}}" class="add-item add-item-child noselect" on-click="{{addItem}}" tabindex="1" on-keyDown="{{onEnterDoClick}}"></a>
                  </template>
                </span>

                
                <template if="{{item.noValue}}">
                  <span class="dash"></span>
                  <a class="new-item-option new-item-text noselect" data-idx="{{item.idx}}" on-click="{{makeItemText}}" on-keyDown="{{onEnterDoClick}}" tabindex="1" title="Make this property a string"></a>
                  <a class="new-item-option new-item-object noselect" data-idx="{{item.idx}}" on-click="{{makeItemObject}}" on-keyDown="{{onEnterDoClick}}" tabindex="1" title="Make this property an object"></a>
                  <a class="new-item-option new-item-array noselect" data-idx="{{item.idx}}" on-click="{{makeItemArray}}" on-keyDown="{{onEnterDoClick}}" tabindex="1" title="Make this property an array"></a>
                </template>

                <template if="{{!item.noValue}}">

                  <template if="{{item.value | isNotObject}}">

                    <span class="dash"></span>

                    <span 
                    data-idx="{{item.idx}}" 
                    class="value" 
                    contenteditable?="{{item.editmode}}" 
                    on-focus="{{doFocus}}" 
                    on-keyDown="{{checkEnterKey}}"
                    on-input="{{doInput}}"
                    on-blur="{{doBlur}}"
                    tabIndex="1">{{item.value}}</span>

                  </template>

                  <template if="{{item.value | isObject}}">

                    <template if="{{kArr[item.idx].value.length}}">
                      <ul class="group cf deep">
                        <template ref="loop_root" repeat="{{item in kArr[item.idx].value}}"></template>
                      </ul>
                    </template>

                    <template if="{{!kArr[item.idx].value.length}}">
                      <ul class="group empty cf deep">
                        <li class="item">This item is empty</li>
                      </ul>
                    </template>

                    <span class="bracket bracket-close {{item.type=='object'?'obj':'arr'}}">
                    </span>
                  </template>

                </template>

              </li>

            </template><!-- end object loop -->

          </ul>

          <div class="cf">
            <span class="bracket bracket-close obj master-bracket"></span>
            <a id="add-item-end" class="add-item add-item-master noselect" on-click="{{addItem}}" tabindex="1" on-keyDown="{{onEnterDoClick}}"></a>
          </div>
          

      </template>

      <template if="{{!obj}}">
        <div id="none-found">{{objError}}</div>
      </template>

    </div>

  </template>


  <script>
  (function(){

    // unique id tracker
    var idx = 0;

    Polymer('jsonymer-editor', {


      // the actual object passed in, in original format
      obj : false,

      // the special compiled object...
      // this is the original object passed in, but in a special
      // format to keep track of changes and meta data...
      cObj : false,

      // key-map array to associate deep children with their corresponding
      // unique ID...this is also used to acquire a specific deep object
      // to modify it, instead of having to travel an arbitrary set of
      // deep object properties (since its in memory and the same object at its core)
      kArr : false,

      // an error string for the user/dev if there is an error with the object
      objError : "Error",

      // reference to the internal data object for the current
      // item in edit mode, if any
      current_edit_item : null,

      // reference to the DOM element of the currently focused item 
      focusedItem : null,

      // cache of current errors that exist in the JSON document
      errors : {},

      // whether the error functionality should be run or not, turn this to false
      // if you don't care about showing the user errors they may make
      // (only automatic internal error is the duplicate-key error)
      errorsOn : true,



      /*
      *
      * POLYMER INTERNAL METHODS
      *
      */
      created : function(){
        this.obj = {};
        this.resetVariables();
      },
      /** END POLYMER INTERNAL METHODS **/


      resetVariables : function(){
        this.cObj = {
          "idx" : -1,
          "value" : [],
          "parent" : false,
          "childKeyIdx" : 0,
          "type" : "object"
        };
        this.kArr = {};
      },






      /*
      *
      * POLYMER TEMPLATE FILTER FUNCTIONS
      *
      * The following are functions used in the template HTML
      * to allow looping of objects, since polymer templates
      * do not support native object iteration yet
      *
      */
      
      // returns true/false if passed argument is an object
      isObject : function(v){
        return typeof(v) === "object";
      },

      // returns true/false if passed argument is NOT an object
      //
      // TODO: maybe there is a way to just use isObject for both
      // instances in the template, but I couldn't find one
      isNotObject : function(v){
        return typeof(v) !== "object";
      },

      isArray : function(v){
        return v instanceof Array
      },

      /** END POLYMER TEMPLATE FILTER FUNCTIONS **/








      /*
      *
      * POLYMER CHANGED EVENT METHODS
      *
      */

      // everytime the obj property changes, we'll need to
      // compile the new object into our special format and reset
      // some variables
      objChanged : function(){
        if(typeof(this.obj) === "object"){
          return this.compileObject();
        }
      },

      /** END POLYMER CHANGED EVENT METHODS **/


      







      /*
      *
      * POLYMER TEMPLATE EVENT HOOKS
      *
      */


      // adds an item to an object/array in the JSON
      addItem : function(e, data, el){

        // get the id of the parent that we want to add an item to
        var parentIdx = el.getAttribute('data-idx');

        // get the parent object
        var targetParent = this.kArr[parentIdx] || this.cObj;

        var eventObj = this.fire('beforeItemAdded', {
          "parent" : targetParent,
        });

        // if the user used preventDefault in their callback for
        // "beforeItemAdded" lets not actually add the item!
        if(eventObj.defaultPrevented){
          return;
        }


        // increment our global unique id index for the new item
        var itemIdx = ++idx;

        // construct a new internal data object for our new item
        var newObj = {
          "idx" : itemIdx, // the unique id
          "key" : "key",   // its temporary key value
          "value" : "value", // its temporary value
          // "editmode" : 1,
          "parent" : targetParent, // the parent of the item
          // initially, the item should have "no value", this distinguishes a "false" value from being "no value"
          "noValue" : true,
          "type" : false, // the initial item type (no type)
          "childKeyIdx" : 0, // this makes adding tons more keys more efficient
        };

        // push the new object to either its parent or the master object (top row)
        if(targetParent){
          if(targetParent.type == "array"){
            var len = targetParent.value.length;
            newObj.key = len;
          }
          targetParent.value.push(newObj);
        }else{
          this.cObj.value.push(newObj);
        }
        
        // add the new object to the key map object
        this.kArr[itemIdx] = newObj;

        // change the key for the item to a new key that won't collide with anything,
        // if the item is a child of an array, don't do this, as their keys need to be
        // incremental
        if(!targetParent || targetParent.type !== "array"){
          newObj.key = this.getAvailableKey(itemIdx);
        }


        // automatically enter edit mode into the new items "key" edit box
        if(targetParent.type !== "array"){
          this.enterEditModeAsync(itemIdx);
        }


        this.asyncFire('itemAdded', {
          item : newObj
        });

        
      },


      removeItem : function(e, data, el){

        var idx = el.getAttribute('data-idx');

        var obj = this.kArr[idx];

        var parent = (obj.parent && obj.parent.value) || this.cObj.value;
        var itemChildOfArray = this.isItemChildOfArray(idx);

        if(parent){

          for(var i=0; i<parent.length; i++){
            var tObj = parent[i];
            if(tObj.idx === obj.idx){

              var eventObj = this.fire('beforeItemRemoved', {
                "item" : obj,
              });

              // if the user used preventDefault in their callback for
              // "beforeItemRemoved" lets not actually remove the item!
              if(eventObj.defaultPrevented){
                return;
              }

              // clear all errors from this item and its children
              this.clearError(idx);
              this.clearDescendingErrors(idx);

              // remove item from parent and key map array
              parent.splice(i, 1);
              this.removeItemFromKeyMap(idx);


              // if the item was an array item, reset its siblings
              // ids so they are in proper incrementing order
              if(itemChildOfArray){
                this.resetChildKeys(parent);
              }
              // if the item is not an array item, lets make sure
              // that any duplicate key errors are resolved
              else{
                this.resetDuplicateKeys(parent, obj.key);
              }

              this.asyncFire('itemRemoved', {
                "idx" : idx,
                "parent" : obj.parent
              });

              return;

            }
          }

        }

      },



      // on focus of item key OR value, enter edit mode for the key/value
      doFocus : function(e, data, el){

        var idx = el.getAttribute('data-idx');

        var obj = this.kArr[idx];

        // if we're trying to focus on a key, and the item is a direct child of
        // an array type, cancel out, because array keys should not be editable
        if(el.classList.contains('key-value') && this.isItemChildOfArray(idx)){
          return;
        }

        this.focusedItem = el;
        this.enterEditMode(idx, el);

        // defer the selection of the items text so it works right
        this.async(function(){
          this.selectElementContents(el);
        }, null);

      },


      // on key down, we check for the enter key to be pressed, as that
      // will trigger the acceptance of the changes
      checkEnterKey : function(e, data, el){

        if(e.which === 13){
          // this prevents a new row for key/value boxes
          e.preventDefault();
          // only accept changes it we're on a value box
          if(el.classList.contains('value')){
            var idx = el.getAttribute('data-idx');
            el.blur();
            // on enter, focus next value (like tab)
            var nextFocusable = this.getNextFocusableItem(idx);
            if(nextFocusable){
              nextFocusable.focus();
            }
          }
        }
      },

      // RUN ON KEY BOXES ONLY
      // on key up, lets auto check if the key is valid and doesn't collide
      // with other sibling keys, show an error if it does
      doKeyUp : function(e, data, el){
        var idx = el.getAttribute('data-idx');
        var v = el.innerText;
        var dup = this.checkDuplicateKeys(idx, v);
        if(dup){
          this.setError(dup.idx, "_dup", "You cannot have duplicate keys in the same level.");
          this.setError(idx, "_dup", "You cannot have duplicate keys in the same level.");
        }else{
          this.clearError(idx, "_dup");
        }
      },


      doInput : function(e, data, el){

        var key = el.classList.contains('key-value');
        var idx = el.getAttribute('data-idx');
        var obj = this.kArr[idx];
        var val = el.textContent || el.innerText;

        var eventName = "propertyValueChanged";
        if(key){
          eventName = "keyValueChanged";
        }

        this.fire(eventName, {
          "value" : val,
          "element" : el,
          "item" : obj
        });

      },


      // on blur of key-value box, exit edit mode and accept the new
      // changes for the item
      doBlur : function(e, data, el){
        var idx = el.getAttribute('data-idx');
        var obj = this.kArr[idx];
        this.clearElementSelection();
        this.exitEditMode();
        this.acceptChanges(idx);
      },

      makeItemText : function(e, data, el){
        var idx = el.getAttribute('data-idx');
        var obj = this.kArr[idx];
        delete obj['noValue'];
        obj.type = "string";
        obj.value = "Value";
        this.enterEditModeAsync(idx, 'value');
      },
      makeItemObject : function(e, data, el){
        var idx = el.getAttribute('data-idx');
        var obj = this.kArr[idx];
        delete obj['noValue'];
        obj.type = "object";
        obj.value = [];

        this.async(function(){
          var itemEl = this.getDomItem(idx);
          itemEl.querySelector("a.add-item[data-idx='"+idx+"']").focus();
        });

      },
      makeItemArray : function(e, data, el){
        var idx = el.getAttribute('data-idx');
        var obj = this.kArr[idx];
        delete obj['noValue'];
        obj.type = "array";
        obj.value = [];

        this.async(function(){
          var itemEl = this.getDomItem(idx);
          itemEl.querySelector("a.add-item[data-idx='"+idx+"']").focus();
        });

      },

      onEnterDoClick : function(e, data, el){
        if(e.which === 13){
          e.preventDefault();
          el.click();
        }
      },

      removeType : function(e, data, el){

        var idx = el.getAttribute('data-idx');
        var obj = this.kArr[idx];

        var eventResp = this.fire('itemTypeRemoved', {
          "item" : obj
        });

        if(eventResp.defaultPrevented){
          return;
        }

        this.clearDescendingErrors(obj.idx);
        this.removeChildrenFromKeyMap(idx);
        obj.value = false;
        obj.noValue = true;
        obj.type = false;

      },

      /** END POLYMER TEMPLATE EVENT HOOKS **/



      // resets an array of array items indexes to be in order
      resetChildKeys : function(children){
        for(var i=0; i<children.length; i++){
          children[i].key = i;
        }
      },


      // takes an array of item children (object items) and a target
      // key and makes sure there is only one of them. this is similar to
      // check duplicate keys but is meant to keep any existing errors if a 
      // duplicate is found and remove any error if only one is found, this
      // is meant for when you don't know anything about the items, but only have
      // a set of children and a single key
      //
      // this fixes a bug where if you had a duplicate key between two items,
      // and you remove the item that DID NOT have the error attached, the item
      // that DID have the error attached will not be resolved of that error
      resetDuplicateKeys : function(children, targetKey){
        var foundItem = false;
        for(var i=0; i<children.length; i++){
          var item = children[i];
          if(item.key === targetKey){
            if(foundItem){
              return;
            }
            foundItem = item;
          }
        }
        this.clearError(foundItem.idx, "_dup");
      },


      // more browser complient method of selecting the contents
      // of a element that using document.execCommand('selectAll')
      selectElementContents : function(el){
          var range = document.createRange();
          range.selectNodeContents(el);
          var sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
      },


      clearElementSelection : function(){
        if(window.getSelection){
          if(window.getSelection().empty){
            window.getSelection().empty();
          }
          else if(window.getSelection().removeAllRanges){
            window.getSelection().removeAllRanges();
          }
        }
        else if(document.selection){
          document.selection.empty();
        }
      },


      getNextItem : function(idx){

        var obj = this.kArr[idx];

        // if item has children, return first child
        if(this.isArray(obj.value) && obj.value.length){
          return obj.value[0];
        }

        var safety = this.getItemLength();

        while(safety-- > 0){
          var sibling = this.getNextSibling(obj.idx);
          if(!sibling && obj.parent){
            obj = obj.parent;
          }else{
            return sibling;
          }
        }
        
        return null;

      },



      getNextSibling : function(idx){
        var obj = this.kArr[idx];
        if(obj){
          // else, go to parent and loop through siblings
          var siblings = (obj.parent && obj.parent.value) || this.cObj.value;
          for(var i=0; i<siblings.length; i++){
            // if we encounter the target and it has a sibling after it, return that
            if(siblings[i] === obj && siblings[i+1]){
              return siblings[i+1];
            }
          }          
        }
        return null;
      },



      getParent : function(idx){
        var obj = this.kArr[idx];
        return obj.parent || this.cObj;
      },


      getNextFocusableItem : function(idx){
        var nextItem = this.getNextItem(idx);
        if(nextItem){
          var item = this.getDomItem(nextItem.idx);
          var focusable = item.querySelector('[tabIndex="1"]');
          if(focusable){
            return focusable;
          }
        }else{
          return this.$['add-item-end'];
        }
      },


      getItemLength : function(){
        return Object.keys(this.kArr).length;
      },



      removeItemFromKeyMap : function(idx){
        
        // this recurses through all descending children
        this.removeChildrenFromKeyMap(idx);
        delete this.kArr[idx];

      },

      removeChildrenFromKeyMap : function(idx){

        var item = this.kArr[idx];
        
        // if item has children, go through each child and remove them first
        // in a recursive many (if child has children has children has children, etc)
        if(item.value instanceof Array){
          for(var i=0; i<item.value.length; i++){
            this.removeItemFromKeyMap(item.value[i].idx);
          }
        }
      },



      setError : function(idx, errorID, str, data){
        
        if(!this.errorsOn){ return; }

        if(!this.errors[idx]){
          this.errors[idx] = {};
        }

        this.errors[idx][errorID] = {
          "error" : str,
          "data" : data
        };

        var $item = this.getDomItem(idx);
        $item.setAttribute('error', true);
        $item.setAttribute('title', str);

        this.fire('edit-error');
      },

      getError : function(idx, errorID){
        return errorID ? this.errors[idx][errorID] : this.errors[idx];
      },


      clearError : function(idx, errorID){

        if(!this.errorsOn){ return; }


        if(this.errors[idx]){

          if(errorID !== undefined){
            delete this.errors[idx][errorID];
          }
          else{
            delete this.errors[idx];
          }

          if(!this.hasError(idx)){
            delete this.errors[idx];
            var $item = this.getDomItem(idx);
            $item.removeAttribute('error');
            $item.removeAttribute('title');

            if(!this.hasError()){
              this.fire('edit-clean');
            }

          }

        }

      },

      // clear all errors existing on any descending child
      // if the item is not of array/object type, it will clear
      // errors from the item itself...if the item IS of array/object
      // type, no errors will be cleared from the passed item itself
      clearDescendingErrors : function(idx){

        if(!this.errorsOn){ return; }

        var obj = this.kArr[idx];

        if(obj.value instanceof Array){
          for(var i=0; i<obj.value.length; i++){
            this.clearDescendingErrors(obj.value[i].idx);
          }
        }else{
          this.clearError(idx);
        }

      },


      hasError : function(idx){
        var toSearch = idx ? this.errors[idx] : this.errors;
        for(var k in toSearch){
          return toSearch[k];
        }
        return false;
      },






      // enters edit mode for a given item, allowing user to edit the value through the keyboard
      // @param: idx - the id of the item to be put into edit mode
      // @param: elToFocus - the element to focus to, which could be either the key element box or value element box
      enterEditMode : function(idx, elToFocus){

        var item = false;

        // set the item to either the elToFocus param or query the key box
        if(elToFocus){
          switch(elToFocus){
            case 'key' :
              item = this.$.master.querySelector('#item-'+idx+' .key-value');
              break;
            case 'value' :
              item = this.$.master.querySelector('#item-'+idx+' .value');
              break;
            default :
              item = elToFocus;
          }
        }else{
          item = this.$.master.querySelector('#item-'+idx+' .key-value');
        }

        // get the item obj to focus
        var obj = this.kArr[idx];

        if(item.classList.contains('key-value') && obj.parent && obj.parent.type === "array"){
          return;
        }

        // if the currently focused item is not the "item-to-focus", focus it
        // which will also blur the current item
        // RETURN
        if(this.focusedItem !== item){
          item.focus();
          return;
        }

        // if the current editor exists, modify its editmode
        // prop to false before we overwrite the current edit item
        // variable entirely
        //
        // TIP: current_edit_item is just a reference to the currently
        // editing items internal object
        if(this.current_edit_item){
          this.current_edit_item.editmode = 0;
        }

        // overwrite the new edit object
        this.current_edit_item = obj;

        item.setAttribute('contenteditable', true);

      },



      // same as enterEditMode, but does it asyncronously
      // to allow the DOM elements to render and everything
      enterEditModeAsync : function(idx, elToFocus){
        return this.async(function(){
          this.enterEditMode(idx, elToFocus);
        }, null, 80);
      },



      // exits the given item from edit mode, this will work whether either key, or value
      // is currently in edit mode
      exitEditMode : function(){

        // if we don't have an edit item, return
        if(!this.current_edit_item){
          return;
        }

        this.current_edit_item.editmode = 0;
        this.current_edit_item = false;
        this.focusedItem.removeAttribute('contenteditable');
        this.focusedItem = false;

      },




      // accept the changes made to a given items key/value value
      // @param: idx - the unique id of the item we want to accept changes for
      acceptChanges : function(idx){

        // get the dom element and also the key/value elements
        var item = this.getDomItem(idx);
        var keyEl = item.querySelector('.key-value[data-idx="'+idx+'"]');
        var valueEl = item.querySelector('.value[data-idx="'+idx+'"]');

        // the item data object
        var obj = this.kArr[idx];

        // get the items "key" value
        if(keyEl){
          var key = keyEl.textContent || keyEl.innerText;
          // if the user entered a key with length, then we can use it
          if(key.length){
            obj.key = key;
          }
          // otherwise, its a blank key, so lets not save it and simply
          // replace the on-screen value with the original key (before edits)
          else{
            if(keyEl.textContent){
              keyEl.textContent = obj.key;
            }else if(keyEl.innerText){
              keyEl.innerText = obj.key;
            }
          }
        }

        // get the items "value" value, same as the above
        if(valueEl){
          var value = valueEl.textContent || valueEl.innerText;
          if(value.length){
            obj.value = value; 
          }else{
            valueEl.innerHTML = obj.value;
          }           
        }

        this.exitEditMode();

      },





      // takes a normal JS object in its final format
      // and converts it to work nicer with the JSON editor...
      // this includes adding meta data and unique ids in order
      // to keep track of changes and data types
      compileObject : function(){

        var _this = this;

        // internal, private method to actually do the compiling, which
        // takes arguments in a specific fashion
        // @param: obj - the object to convert
        // @param: target - the target array the compiled object should go into
        // @param: [parent] - the parent of the current object, if needed for deep objects
        var runCompiler = function(obj, target, parent){

          for(var k in obj){

            var i = ++idx;

            var nObj = {
              "key" : k,
              "idx" : i,
              "editmode" : 0,
              "parent" : parent || false,
              "childKeyIdx" : 0        
            };

            if(nObj.key === "_id" && !nObj.parent){
              nObj.locked = 1;
            }

            target.push(nObj);
            _this.kArr[i] = nObj;

            if(typeof(obj[k]) === "object"){
              nObj.value = [];
              if(obj[k] instanceof Array){
                nObj.type = "array";
              }else{
                nObj.type = "object";
              }
              runCompiler(obj[k], nObj.value, nObj);
            }
            else{
              nObj.type = "string";
              nObj.value = obj[k];
            }
          }
        };

        // reset some variables to ensure the compilation comes out correctly
        idx = 0;
        // this.cObj = [];
        this.resetVariables();
        return runCompiler(this.obj, this.cObj.value, this.cObj);


      },




      // checks a particular object item if any of its siblings have the same key
      // (because no object level can have duplicate keys)...
      // @param: idx - the unique id of the item to compare
      // @param: value - the key value to compare with
      // @return: true, if duplicate is FOUND
      checkDuplicateKeys : function(idx, value){
        var item = this.kArr[idx];
        var parent = item.parent;
        var children = null;

        // if no parent is found, consider the compiled object the parent,
        // as well as the children
        if(!parent){
          parent = this.cObj;
          children = parent;
        }
        // otherwise, the children to compare with are the children of the item's parent
        else{
          children = parent.value;
        }

        // loop through children and check if any keys match, return true if so
        if(parent){
          for(var i=0; i<children.length; i++){
            var sib = children[i];
            if(sib.idx !== item.idx && sib.key === value){
              return sib;
            }
          }
        }

        // nothing matched or something else happened
        return false;

      },




      // generates a key that is available to use, taking into
      // account the given items siblings...the key is in the form
      // of "key (n)", with 'n' being an incremented integer from the
      // previous instance of "key (n-1)"...
      //
      // @param: idx - the unique id of the item to generate a key for
      // @return: key (string) a valid key that the item can use
      getAvailableKey : function(idx){

        // start with just "key"
        var prefix = "key";
        var key = prefix;

        var obj = this.kArr[idx];

        // start with 1 as the incrementer
        // var i = ++obj.parent.childKeyIdx;

        // as long as the current key is taken, we'll change
        // the increment number until it works
        while(this.checkDuplicateKeys(idx, key)){
          key = prefix + " (" + (++obj.parent.childKeyIdx) + ")";
        }

        // return either 'key' or 'key (n)'
        return key;

      },


      // returns the dom element for the item with the passed unique id
      // @param: idx - the unique id of the object item you need
      // @return: dom element of the wrapper element that holds the items
      // key and value (which could be comprised of children)
      getDomItem : function(idx){
        return this.$.master.querySelector('#item-'+idx);
      },

      // returns true or false based on whether the given item is a direct
      // child of an array item type, this is useful in situations in which
      // we need to do certain things for direct array children
      // @param: idx - the id of the child item
      isItemChildOfArray : function(idx){
        var obj = this.kArr[idx];
        return obj && obj.parent && obj.parent.type === "array";
      },


      // returns a JS object in the plain form that the user would expect,
      // relative to what they see on screen...this is what you'd use to
      // retrieve the final, pure data object that the user has created
      toJSON : function(){
        return this.reconstructObject(this.cObj.value, {});
      },



      // used in the above toJSON method to create the final JSON object,
      // this should really only be used internally, as the params are somewhat
      // specific to implementation and instance
      // @param: obj - should be this.cObj in order to work correctly
      // @param: target - should initially be plain js object ({}) to start things off
      reconstructObject : function(obj, target){

        // for each item in the compiled object array (cObj)
        for(var i=0; i<obj.length; i++){

          var o = obj[i];

          // if the item doesnt have a designated type,
          // don't include it in the final product
          if(!o.type){
            continue;
          }

          var key = o.key;
          var val = o.value;

          // if the items value is an object type,
          // it must have children
          if(typeof(val) === "object"){
            // array types obviously become arrays
            if(o.type === "array"){
              target[key] = [];
            }
            // object types obviously become objects
            else{
              target[key] = {};
            }
            // recurse back through with the new value array
            // and the child object
            this.reconstructObject(o.value, target[key]);
          }
          // otherwise, we're dealing with a static string or number (no children)
          else{
            target[key] = val;
          }
        }
        // end loop

        return target;
      
      }



    });




  })();
  </script>

</polymer-element>


























